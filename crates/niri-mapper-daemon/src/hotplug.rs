//! Device hot-plug monitoring via udev
//!
//! This module provides the [`HotplugMonitor`] struct for detecting input device
//! connect/disconnect events using udev. It enables the daemon to automatically
//! grab/release devices without requiring a restart.

use std::path::PathBuf;

use anyhow::{Context, Result};
use tokio_stream::StreamExt;

/// Events generated by the hot-plug monitor.
///
/// These events represent input device add/remove actions detected via udev.
/// The daemon uses these to dynamically grab or release devices.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HotplugEvent {
    /// A new input device was connected.
    Add {
        /// Path to the device node (e.g., `/dev/input/event5`)
        devnode: PathBuf,
    },
    /// An input device was disconnected.
    Remove {
        /// Path to the device node (e.g., `/dev/input/event5`)
        devnode: PathBuf,
    },
}

/// Monitors for input device hot-plug events via udev.
///
/// The `HotplugMonitor` wraps a `tokio_udev::AsyncMonitorSocket` that listens for
/// udev events filtered to the "input" subsystem. It provides an async interface
/// for receiving device add/remove events.
///
/// # Example
///
/// ```ignore
/// let monitor = HotplugMonitor::new()?;
/// while let Some(event) = monitor.next_event().await {
///     match event {
///         HotplugEvent::Add { devnode } => {
///             println!("Device added: {:?}", devnode);
///         }
///         HotplugEvent::Remove { devnode } => {
///             println!("Device removed: {:?}", devnode);
///         }
///     }
/// }
/// ```
pub struct HotplugMonitor {
    /// The underlying tokio-udev async monitor socket for async event reception.
    /// Filtered to only receive events from the "input" subsystem.
    socket: tokio_udev::AsyncMonitorSocket,
}

impl HotplugMonitor {
    /// Creates a new hot-plug monitor for input devices.
    ///
    /// This sets up a udev monitor filtered to the "input" subsystem, which will
    /// receive events for input devices (keyboards, mice, etc.) being added or removed.
    ///
    /// # Errors
    ///
    /// Returns an error if the udev monitor cannot be created or configured.
    pub fn new() -> Result<Self> {
        let monitor_socket = tokio_udev::MonitorBuilder::new()
            .context("Failed to create udev monitor builder")?
            .match_subsystem("input")
            .context("Failed to add input subsystem filter")?
            .listen()
            .context("Failed to start listening for udev events")?;

        let socket = tokio_udev::AsyncMonitorSocket::new(monitor_socket)
            .context("Failed to create async monitor socket")?;

        Ok(Self { socket })
    }

    /// Returns the next hotplug event from the monitor.
    ///
    /// This method asynchronously waits for the next udev event and converts it
    /// to a [`HotplugEvent`]. Only events for `/dev/input/event*` devices are
    /// returned; other input devices (like `mouse*`, `js*`) are filtered out.
    ///
    /// # Returns
    ///
    /// - `Some(HotplugEvent)` when a device is added or removed
    /// - `None` if the monitor encounters a non-recoverable error
    ///
    /// # Example
    ///
    /// ```ignore
    /// let mut monitor = HotplugMonitor::new()?;
    /// while let Some(event) = monitor.next_event().await {
    ///     match event {
    ///         HotplugEvent::Add { devnode } => println!("Added: {:?}", devnode),
    ///         HotplugEvent::Remove { devnode } => println!("Removed: {:?}", devnode),
    ///     }
    /// }
    /// ```
    pub async fn next_event(&mut self) -> Option<HotplugEvent> {
        loop {
            // Wait for the next udev event
            let event = match self.socket.next().await {
                Some(Ok(event)) => event,
                Some(Err(_)) => {
                    // Continue on transient errors
                    continue;
                }
                None => {
                    // Stream ended (non-recoverable)
                    return None;
                }
            };

            // Only process "add" and "remove" actions
            let action = match event.action() {
                Some(action) => action,
                None => continue,
            };

            // Get the sysname to filter for event* devices
            let sysname = match event.sysname().to_str() {
                Some(name) => name,
                None => continue,
            };

            // Filter to only event* devices (ignore mouse*, js*, etc.)
            if !sysname.starts_with("event") {
                continue;
            }

            // Get the device node path
            let devnode = match event.devnode() {
                Some(path) => path.to_path_buf(),
                None => continue,
            };

            // Map action to HotplugEvent
            if action == "add" {
                return Some(HotplugEvent::Add { devnode });
            } else if action == "remove" {
                return Some(HotplugEvent::Remove { devnode });
            }
            // Ignore other actions (bind, unbind, change, etc.)
        }
    }
}
